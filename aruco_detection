import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image
from visualization_msgs.msg import Marker
from cv_bridge import CvBridge
import cv2
import cv2.aruco as aruco
import numpy as np
import math
import tf2_ros
from tf2_ros import TransformException

class ArucoMapMarker(Node):
    """
    一个集成的 ROS 2 节点，用于检测 ArUco 标记并使用 TF2 将其定位在地图上。
    
    它通过 ROS 2 参数进行完全配置，使其能够：
    1. 兼容模拟器 (使用默认的理想摄像头参数)
    2. 兼容真实机器人 (通过加载标定过的摄像头参数)
    """
    def __init__(self):
        super().__init__('aruco_map_marker')

        # --- [关键] 声明所有可配置参数 ---
        
        # 1. 话题和框架 (Topics & Frames)
        self.declare_parameter('camera_topic', '/camera/image_raw')
        self.declare_parameter('target_frame', 'map') # 目标坐标系 (真实: 'map', 模拟: 'odom')
        self.declare_parameter('robot_frame', 'base_link')
        
        # 2. ArUco 详情
        self.declare_parameter('aruco_dictionary', 'DICT_6X6_250')
        self.declare_parameter('marker_size', 0.1) # 单位：米

        # 3. [新] 摄像头标定参数 (默认为模拟器的理想值)
        # 摄像头内参矩阵 (9 个值的列表)
        self.declare_parameter('camera_matrix', [
            600.0, 0.0, 320.0,
            0.0, 600.0, 240.0,
            0.0, 0.0, 1.0
        ])
        # 摄像头畸变系数 (5 个值的列表)
        self.declare_parameter('distortion_coefficients', [0.0, 0.0, 0.0, 0.0, 0.0])

        # --- 内部状态变量 ---
        self.bridge = CvBridge()
        self.detected_marker_ids = set()

        # --- 从参数服务器获取值 ---
        camera_topic_name = self.get_parameter('camera_topic').get_parameter_value().string_value
        dict_name = self.get_parameter('aruco_dictionary').get_parameter_value().string_value
        self.marker_length_meters = self.get_parameter('marker_size').get_parameter_value().double_value
        self.target_frame = self.get_parameter('target_frame').get_parameter_value().string_value
        self.robot_frame = self.get_parameter('robot_frame').get_parameter_value().string_value
        
        # [新] 获取标定参数并转换为 Numpy 矩阵
        cam_matrix_list = self.get_parameter('camera_matrix').get_parameter_value().double_array_value
        dist_coeffs_list = self.get_parameter('distortion_coefficients').get_parameter_value().double_array_value
        
        self.camera_matrix = np.array(cam_matrix_list, dtype=np.float32).reshape((3, 3))
        self.dist_coeffs = np.array(dist_coeffs_list, dtype=np.float32)

        # --- ArUco 检测器初始化 ---
        try:
            aruco_dict_value = getattr(aruco, dict_name)
            self.aruco_dict = aruco.getPredefinedDictionary(aruco_dict_value)
        except AttributeError:
            self.get_logger().fatal(f"无效的 ArUco 字典: {dict_name}. 节点将关闭。")
            self.destroy_node(); return
            
        self.aruco_params = aruco.DetectorParameters() 

        # --- TF2 监听器 ---
        self.tf_buffer = tf2_ros.Buffer()
        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer, self)

        # --- ROS 2 订阅者和发布者 ---
        self.image_subscriber = self.create_subscription(
            Image, camera_topic_name, self.image_callback, 10)
        self.marker_publisher = self.create_publisher(Marker, '/aruco_markers', 10)

        # --- 打印加载的配置 ---
        self.get_logger().info(f"ArUco 节点已启动。")
        self.get_logger().info(f"  > 监听话题: '{camera_topic_name}'")
        self.get_logger().info(f"  > 变换框架: '{self.target_frame}' <- '{self.robot_frame}'")
        self.get_logger().info(f"  > 标记尺寸: {self.marker_length_meters} 米")
        self.get_logger().info(f"  > 字典: '{dict_name}'")
        self.get_logger().info(f"  > 加载的内参 K: \n{self.camera_matrix}")
        self.get_logger().info(f"  > 加载的畸变 D: {self.dist_coeffs}")
        self.get_logger().info("等待图像和 TF 变换...")

    def image_callback(self, msg):
        """主回调：获取图像，查找TF，检测标记，计算位置，发布标记。"""
        try:
            # 1. 获取机器人姿态
            trans = self.tf_buffer.lookup_transform(
                self.target_frame, self.robot_frame, rclpy.time.Time())
        except TransformException as ex:
            self.get_logger().warn(f'无法获取 TF 变换: {ex}', throttle_duration_sec=5.0)
            return

        # 2. 提取 2D 姿态
        x_robot = trans.transform.translation.x
        y_robot = trans.transform.translation.y
        orient = trans.transform.rotation
        siny_cosp = 2 * (orient.w * orient.z + orient.x * orient.y)
        cosy_cosp = 1 - 2 * (orient.y * orient.y + orient.z * orient.z)
        theta_robot = math.atan2(siny_cosp, cosy_cosp)
        
        # 3. 图像处理
        try:
            cv_image = self.bridge.imgmsg_to_cv2(msg, "bgr8")
        except Exception as e:
            self.get_logger().error(f"图像转换失败: {e}"); return
            
        # 4. ArUco 检测
        corners, ids, _ = aruco.detectMarkers(
            cv_image, self.aruco_dict, parameters=self.aruco_params)

        if ids is None:
            self.get_logger().info('未在此帧中检测到标记。', throttle_duration_sec=10.0)
            return

        # 5. 姿态估计 (使用加载的标定参数)
        rvecs, tvecs, _ = aruco.estimatePoseSingleMarkers(
            corners, self.marker_length_meters, self.camera_matrix, self.dist_coeffs)

        for i, marker_id_array in enumerate(ids):
            marker_id = int(marker_id_array[0])

            if marker_id not in self.detected_marker_ids:
                # 6. 坐标变换
                tvec = tvecs[i][0]
                x_marker_in_cam = tvec[0]
                z_marker_in_cam = tvec[2] 

                # 摄像头坐标系 -> 机器人 (base_link) 坐标系 (假设 Z_cam 向前, X_cam 向右)
                x_marker_in_robot = z_marker_in_cam
                y_marker_in_robot = -x_marker_in_cam
                
                # 机器人 (base_link) -> 地图 (map) 坐标系
                x_marker_in_map = x_robot + x_marker_in_robot * math.cos(theta_robot) - y_marker_in_robot * math.sin(theta_robot)
                y_marker_in_map = y_robot + x_marker_in_robot * math.sin(theta_robot) + y_marker_in_robot * math.cos(theta_robot)
                
                self.detected_marker_ids.add(marker_id)
                self.get_logger().info(f"--> [发现新标记!] ID: {marker_id}, 地图坐标: x={x_marker_in_map:.2f}, y={y_marker_in_map:.2f}")
                
                self.publish_marker(marker_id, x_marker_in_map, y_marker_in_map)

    def publish_marker(self, marker_id, x_pos, y_pos):
        """为 RViz 创建并发布永久的绿色立方体和文本。"""
        
        common_header = rclpy.time.Time.to_msg(self.get_clock().now())
        
        point_marker = Marker()
        point_marker.header.frame_id = self.target_frame
        point_marker.header.stamp = common_header
        point_marker.ns = "aruco_points"
        point_marker.id = marker_id
        point_marker.type = Marker.CUBE
        point_marker.action = Marker.ADD
        point_marker.pose.position.x = x_pos
        point_marker.pose.position.y = y_pos
        point_marker.pose.position.z = 0.05 
        point_marker.pose.orientation.w = 1.0
        point_marker.scale.x = 0.1
        point_marker.scale.y = 0.1
        point_marker.scale.z = 0.1
        point_marker.color.g = 1.0
        point_marker.color.a = 1.0
        point_marker.lifetime = rclpy.duration.Duration(seconds=0).to_msg()
        
        text_marker = Marker(
            header=point_marker.header,
            ns="aruco_labels",
            id=marker_id,
            type=Marker.TEXT_VIEW_FACING,
            action=Marker.ADD,
            pose=point_marker.pose,
            scale=Marker().scale(z=0.15),
            color=Marker().color(r=1.0, g=1.0, b=1.0, a=1.0),
            text=f"ID: {marker_id}",
            lifetime=point_marker.lifetime
        )
        text_marker.pose.position.z = 0.2 # 文本在立方体上方

        self.marker_publisher.publish(point_marker)
        self.marker_publisher.publish(text_marker)
        self.get_logger().info(f"    已在地图上为 ID: {marker_id} 发布标记。")

def main(args=None):
    rclpy.init(args=args)
    aruco_map_marker_node = ArucoMapMarker()
    try:
        rclpy.spin(aruco_map_marker_node)
    except KeyboardInterrupt:
        pass
    finally:
        aruco_map_marker_node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
